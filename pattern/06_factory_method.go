package pattern

import (
	"fmt"
)

/*
	Реализовать паттерн «фабричный метод».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Factory_method_pattern

Фабричный метод — это порождающий паттерн проектирования,
который определяет общий интерфейс для создания объектов в суперклассе,
позволяя подклассам изменять тип создаваемых объектов.

Надобность:
Когда нужно создавать объекты разных типов, но работать с ними одинаково.
Когда не хотим жёстко привязываться к конкретным классам.
Когда объект может изменяться в будущем (например, добавятся новые виды транспорта).

Плюсы:
Избавляет класс от привязки к конкретным классам продуктов.
Выделяет код производства продуктов в одно место, упрощая поддержку кода.
Упрощает добавление новых продуктов в программу.
Реализует принцип открытости/закрытости.

Минус:
Может привести к созданию больших параллельных иерархий классов,
так как для каждого класса продукта надо создать свой подкласс создателя.


Пример:
К нам приходят файлы трех расширений .txt, .png, .doc.
В зависимости от расширения файла мы должны сохранять его в одном из каталогов /file/txt/, /file/png/ и /file/doc/.
Значит, у нас будет файловая фабрика с параметризированным фабричным методом,
принимающим путь к файлу, который нам нужно сохранить в одном из каталогов.
Этот фабричный метод возвращает нам объект, используя который мы можем манипулировать с нашим файлом
(сохранить, посмотреть тип и каталог для сохранения).
Заметьте, мы никак не указываем какой экземпляр объекта-продукта нам нужно получить,
это делает фабричный метод путем определения расширения файла и на его основе выбора
подходящего класса продукта. Тем самым, если наша система будет расширяться и доступных расширений файлов
станет, например 25, то нам всего лишь нужно будет изменить фабричный метод и реализовать классы продуктов.
*/

/*
Выбор платёжной системы (PayPal, Master, Visa) - Фабричный метод, который позволяет
динамически выбирать нужный процессинг без привязки к конкретной реализации.
*/

// Интерфейс, который должны реализовать все платёжные системы
type Payment interface {
	ProcessPayment(sum float64) string
}

// Фабричный метод выбора платежной системы
func GetPaymant(prodiver string) Payment {
	switch prodiver {
	case "paypal":
		return &PayPal{}
	case "visa":
		return &Visa{}
	case "master":
		return &Master{}
	default:
		return nil
	}
}

type PayPal struct{}

func (p *PayPal) ProcessPayment(sum float64) string {
	return fmt.Sprintf("Оплата PayPal - $%.2f", sum)
}

type Master struct{}

func (m *Master) ProcessPayment(sum float64) string {
	return fmt.Sprintf("Оплата Master - $%.2f", sum)
}

type Visa struct{}

func (v *Visa) ProcessPayment(sum float64) string {
	return fmt.Sprintf("Оплата Visa - $%.2f", sum)
}
